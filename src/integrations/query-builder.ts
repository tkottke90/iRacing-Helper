import { QueryInterface } from '../interfaces/database';

type NodePropKeys = string | number | symbol;

const nodeVarIndex = 'abcdefghijklmnopqrstuvwxyz'.split('');

export class Neo4jQueryBuilder<Nodes extends string = never> {
  private lastNodeVar = '';
  private lastNodeVarIndex = 0;

  private nodes: Map<string, { nodeVar: string; label: string }> = new Map();
  private params: Record<string, any> = {};

  private query: string[] = [];
  private return = '';

  build() {
    const nodeKeys = Array.from(this.nodes.keys());

    return {
      query: [
        ...this.query,
        this.return ? this.return : `RETURN ${nodeKeys.join(', ')}`
      ].join(' '),
      params: this.params
    };
  }

  buildNodeReference(
    nodeVar: string,
    label = '',
    properties: Record<string, string | number | boolean | null> = {}
  ) {
    const { parameterizedString, parameters } = this.generatePropertySelectors(
      nodeVar,
      properties
    );

    this.params = { ...this.params, ...parameters };

    return [
      '(',
      nodeVar,
      label ? `:${label}` : '',
      parameterizedString,
      ')'
    ].join('');
  }

  peek() {
    if (!process.env.NODE_ENV?.startsWith('prod')) {
      console.dir(this.build());
    }

    return this;
  }

  customReturn<SelectedNodes extends Nodes>(...nodes: SelectedNodes[]) {
    this.return = `RETURN ${nodes.join(',')}`;
    return this;
  }

  /**
   * Add a MATCH clause for a node with the given label
   * @param label The node label
   * @param nodeVar Optional variable name for the node (auto-generated if not provided).  Note that the autogenerated value is not typed so it wont show up in other methods
   * @param conditions Optional conditions for the node
   * @returns The QueryBuilder instance for chaining
   */
  select<Node extends string>(label: string, nodeVar?: Node, filter?: any) {
    const node = this.generateNodeVar(nodeVar);
    this.nodes.set(node, { nodeVar: node, label });

    this.query.push(`MATCH ${this.buildNodeReference(node, label, filter)}`);

    return this as unknown as Neo4jQueryBuilder<Nodes | Node>;
  }

  private generateNodeVar(variable?: string) {
    let nodeVar = variable;

    // When the node variable is not provided, we need to generate it
    if (!nodeVar) {
      // The node name will be a concatenation of a prefix and the next letter in the alphabet.
      // This provides a simple continuious list of generic node names.
      //
      // Example:
      //    - a
      //    - b
      //    - c
      //    - ...
      //    - z
      //    - aa
      //    - ab
      //    - ac
      //    - ...
      //
      nodeVar = this.lastNodeVar + nodeVarIndex[this.lastNodeVarIndex];

      this.lastNodeVarIndex++;

      // If we have reached the end of the alphabet, we need to reset the index
      // and increment the prefix
      if (this.lastNodeVarIndex > nodeVarIndex.length - 1) {
        this.lastNodeVarIndex = 0;
        this.lastNodeVar += nodeVarIndex[this.lastNodeVarIndex];
      }
    }

    // Particularly when the variable is provided, we should make sure that
    // the node variable is unique.  We can do this by adding a index suffix
    // to the node variable when the node variable already exists
    if (this.nodes.has(nodeVar)) {
      const nodeIndex = this.similarNodes(nodeVar).length;
      nodeVar = `${nodeVar}_${nodeIndex}`;
    }

    return nodeVar;
  }

  private generatePropertySelectors(
    nodeVar: string,
    record: Record<NodePropKeys, unknown>
  ) {
    // If there are no keys, then there are no parameters
    if (Object.keys(record).length === 0) {
      return {
        parameterizedString: '',
        parameters: {}
      };
    }

    const parameterizedStrArr: string[] = [];
    const params: Record<string, unknown> = {};

    // Loop through each of the keys and add to the parameterized string and parameters map
    for (const [key, value] of Object.entries(record)) {
      // Create a unique key for each parameter
      const paramKey = `${nodeVar}_${key}`;

      params[paramKey] = value;
      parameterizedStrArr.push(`${key}: $${paramKey}`);
    }

    return {
      parameterizedString: ` {${parameterizedStrArr.join(', ')}}`,
      parameters: params
    };
  }

  /**
   * Extract a list of nodes that have the same starting values as
   * the provided node variable.  This can be used to determine how
   * many nodes have a similar name and to increment them as to avoid
   * collisions
   *
   * @param nodeVar The variable to check for similar nodes
   * @returns A list of nodes that have the same starting values as the provided node variable
   */
  private similarNodes(nodeVar: string) {
    return Array.from(this.nodes.keys()).filter((node) =>
      node.startsWith(nodeVar)
    );
  }
}

const test = new Neo4jQueryBuilder()
  .select('TestLabel', 'test', { id: 1 })
  .customReturn('test')
  .peek();
